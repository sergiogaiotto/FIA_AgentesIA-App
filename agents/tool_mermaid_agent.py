# agents/tool_mermaid_agent.py - Comentado Linha a Linha

# Agente Tool Mermaid - Gera√ß√£o de diagramas usando Mermaid via MCP
# Coment√°rio descritivo: agente especializado em criar diagramas de sequ√™ncia e outros tipos

import os
# M√≥dulo padr√£o para intera√ß√£o com sistema operacional

import asyncio
# Biblioteca para programa√ß√£o ass√≠ncrona

import json
# M√≥dulo para manipula√ß√£o de dados JSON

from typing import List, Dict, Any, Optional
# Type hints para melhor documenta√ß√£o e type safety

# Imports do MCP (Model Context Protocol)
from mcp import ClientSession, StdioServerParameters
# ClientSession: classe para gerenciar sess√£o MCP
# StdioServerParameters: configura√ß√£o para comunica√ß√£o via stdio

from mcp.client.stdio import stdio_client
# Cliente MCP para comunica√ß√£o via standard input/output

# LangGraph para agentes ReAct
from langgraph.prebuilt import create_react_agent
# LangGraph: framework para criar fluxos de agentes complexos

# Modelo OpenAI
from langchain_openai import ChatOpenAI
# Integra√ß√£o LangChain com API OpenAI

from langchain_core.messages import HumanMessage, SystemMessage
# Tipos de mensagem padronizados do LangChain

# Pydantic para modelos de dados
from pydantic import BaseModel, Field
# BaseModel: valida√ß√£o e serializa√ß√£o
# Field: metadados para campos

# Carregamento de vari√°veis de ambiente
from dotenv import load_dotenv
# Biblioteca para carregar vari√°veis de arquivo .env

# Carrega vari√°veis de ambiente
load_dotenv()


# ===============================
# MODELOS PYDANTIC
# ===============================

class MermaidRequest(BaseModel):
    """Modelo para requisi√ß√µes de gera√ß√£o de diagrama"""
    prompt: str = Field(..., description="Descri√ß√£o do diagrama em linguagem natural")
    # Campo obrigat√≥rio: descri√ß√£o do que o usu√°rio quer no diagrama
    
    diagram_type: str = Field(default="sequence", description="Tipo de diagrama Mermaid")
    # Tipo padr√£o: sequence diagram, mas pode ser flowchart, gantt, etc.
    
    style: Optional[str] = Field(default=None, description="Estilo personalizado do diagrama")
    # Estilo opcional para customiza√ß√£o visual


class MermaidResponse(BaseModel):
    """Modelo para resposta do diagrama gerado"""
    mermaid_code: str = Field(..., description="C√≥digo Mermaid gerado")
    # C√≥digo Mermaid que ser√° renderizado
    
    explanation: str = Field(..., description="Explica√ß√£o do diagrama")
    # Explica√ß√£o em linguagem natural do que o diagrama representa
    
    diagram_type: str = Field(..., description="Tipo de diagrama gerado")
    # Tipo de diagrama que foi criado
    
    suggestions: List[str] = Field(default_factory=list, description="Sugest√µes de melhorias")
    # Lista de sugest√µes para melhorar o diagrama


# ===============================
# PROMPTS ORGANIZADOS
# ===============================

class MermaidPrompts:
    """Container para prompts organizados por categoria"""
    
    # System prompt para gera√ß√£o de diagramas
    MERMAID_GENERATION_SYSTEM = """Voc√™ √© um especialista em cria√ß√£o de diagramas Mermaid. 
    Sua fun√ß√£o √© converter descri√ß√µes em linguagem natural em diagramas Mermaid bem estruturados.
    
    Capabilities:
    - Sequence Diagrams: para mostrar intera√ß√µes entre entidades
    - Flowcharts: para mostrar fluxos de processo
    - Class Diagrams: para mostrar estruturas OOP
    - State Diagrams: para mostrar m√°quinas de estado
    - Gantt Charts: para mostrar cronogramas
    - ER Diagrams: para mostrar modelos de dados
    
    Sempre:
    1. Gere c√≥digo Mermaid v√°lido e bem formatado
    2. Use nomes descritivos para elementos
    3. Inclua coment√°rios quando necess√°rio
    4. Mantenha o diagrama claro e leg√≠vel
    5. Sugira melhorias quando apropriado
    
    Output Format:
    - C√≥digo Mermaid completo e v√°lido
    - Explica√ß√£o clara do diagrama
    - Sugest√µes de melhorias se aplic√°vel"""

    @staticmethod
    def generate_diagram_prompt(prompt: str, diagram_type: str) -> str:
        """Template para gera√ß√£o de diagramas"""
        return f"""User Request: {prompt}
        
Requested Diagram Type: {diagram_type}

Please generate a Mermaid diagram based on this description. Follow these guidelines:

1. Create valid Mermaid syntax for {diagram_type}
2. Use clear, descriptive labels
3. Ensure proper flow and structure
4. Add styling when appropriate
5. Make it professional and easy to understand

Provide:
1. Complete Mermaid code (wrapped in ```mermaid ... ```)
2. Brief explanation of the diagram
3. Any suggestions for improvements or alternatives

Focus on clarity and accuracy."""


# ===============================
# AGENTE TOOL MERMAID PRINCIPAL
# ===============================

class ToolMermaidAgent:
    """Agente especializado em gera√ß√£o de diagramas Mermaid via MCP"""
    # Classe principal que orquestra gera√ß√£o de diagramas
    
    def __init__(self):
        """Inicializa agente Mermaid com configura√ß√µes necess√°rias"""
        
        # Valida√ß√£o de chaves de API
        self.openai_key = os.getenv("OPENAI_API_KEY")
        if not self.openai_key:
            raise ValueError("OPENAI_API_KEY n√£o encontrada nas vari√°veis de ambiente")
        
        # Configura√ß√£o do modelo LLM
        self.model = ChatOpenAI(
            model="gpt-4o-mini",
            # Modelo otimizado para tarefas de gera√ß√£o de c√≥digo
            temperature=0.1,
            # Baixa temperatura para consist√™ncia em gera√ß√£o de c√≥digo
            openai_api_key=self.openai_key
        )
        
        # Configura√ß√£o do servidor MCP (pode usar ferramentas MCP se dispon√≠veis)
        firecrawl_key = os.getenv("FIRECRAWL_API_KEY")
        if firecrawl_key:
            self.server_params = StdioServerParameters(
                command="npx",
                env={"FIRECRAWL_API_KEY": firecrawl_key},
                args=["firecrawl-mcp"]
            )
            self.mcp_available = True
        else:
            self.server_params = None
            self.mcp_available = False
        
        # Prompts organizados
        self.prompts = MermaidPrompts()
        
        # Hist√≥rico de diagramas gerados
        self.diagram_history: List[Dict[str, Any]] = []
        
        print("‚úÖ Tool Mermaid Agent inicializado")
    
    async def generate_diagram(self, request: MermaidRequest) -> MermaidResponse:
        """
        Gera diagrama Mermaid baseado na requisi√ß√£o
        
        Args:
            request: Requisi√ß√£o com descri√ß√£o do diagrama
            
        Returns:
            Resposta com c√≥digo Mermaid e explica√ß√£o
        """
        try:
            print(f"üé® Gerando diagrama {request.diagram_type}: {request.prompt[:100]}...")
            
            # Prepara mensagens para o LLM
            messages = [
                SystemMessage(content=self.prompts.MERMAID_GENERATION_SYSTEM),
                HumanMessage(content=self.prompts.generate_diagram_prompt(
                    request.prompt, 
                    request.diagram_type
                ))
            ]
            
            # Gera resposta usando LLM
            response = self.model.invoke(messages)
            response_content = response.content
            
            # Extrai c√≥digo Mermaid da resposta
            mermaid_code = self._extract_mermaid_code(response_content)
            
            # Gera explica√ß√£o
            explanation = self._extract_explanation(response_content)
            
            # Gera sugest√µes
            suggestions = self._extract_suggestions(response_content)
            
            # Cria resposta estruturada
            mermaid_response = MermaidResponse(
                mermaid_code=mermaid_code,
                explanation=explanation,
                diagram_type=request.diagram_type,
                suggestions=suggestions
            )
            
            # Adiciona ao hist√≥rico
            self.diagram_history.append({
                "timestamp": asyncio.get_event_loop().time(),
                "request": request.model_dump(),
                "response": mermaid_response.model_dump()
            })
            
            print(f"‚úÖ Diagrama {request.diagram_type} gerado com sucesso")
            return mermaid_response
            
        except Exception as e:
            print(f"‚ùå Erro ao gerar diagrama: {e}")
            return MermaidResponse(
                mermaid_code="graph TD\n    A[Erro] --> B[Falha na gera√ß√£o]",
                explanation=f"Erro ao gerar diagrama: {str(e)}",
                diagram_type=request.diagram_type,
                suggestions=["Tente reformular a descri√ß√£o", "Verifique se o tipo de diagrama est√° correto"]
            )
    
    def _extract_mermaid_code(self, response: str) -> str:
        """Extrai c√≥digo Mermaid da resposta do LLM"""
        # Procura por blocos de c√≥digo Mermaid
        import re
        
        # Pattern para ```mermaid ... ```
        mermaid_pattern = r'```mermaid\s*(.*?)\s*```'
        match = re.search(mermaid_pattern, response, re.DOTALL | re.IGNORECASE)
        
        if match:
            return match.group(1).strip()
        
        # Pattern alternativo para ``` ... ``` ap√≥s mencionar mermaid
        code_pattern = r'```\s*(.*?)\s*```'
        matches = re.findall(code_pattern, response, re.DOTALL)
        
        if matches:
            # Retorna o primeiro bloco de c√≥digo encontrado
            return matches[0].strip()
        
        # Fallback: tenta extrair linhas que parecem c√≥digo Mermaid
        lines = response.split('\n')
        mermaid_lines = []
        in_diagram = False
        
        for line in lines:
            line = line.strip()
            if any(keyword in line.lower() for keyword in ['graph', 'sequenceDiagram', 'classDiagram', 'stateDiagram', 'gantt']):
                in_diagram = True
            
            if in_diagram and line:
                mermaid_lines.append(line)
            elif in_diagram and not line:
                break
        
        if mermaid_lines:
            return '\n'.join(mermaid_lines)
        
        # √öltimo fallback: exemplo b√°sico baseado no tipo
        return self._get_fallback_diagram()
    
    def _extract_explanation(self, response: str) -> str:
        """Extrai explica√ß√£o da resposta do LLM"""
        # Procura por se√ß√µes de explica√ß√£o
        lines = response.split('\n')
        explanation_lines = []
        capturing = False
        
        for line in lines:
            line = line.strip()
            
            # Identifica in√≠cio de explica√ß√£o
            if any(keyword in line.lower() for keyword in ['explanation', 'explica√ß√£o', 'descri√ß√£o', 'este diagrama']):
                capturing = True
                if line.lower().startswith(('explanation', 'explica√ß√£o')):
                    continue
            
            # Captura linhas da explica√ß√£o
            if capturing and line and not line.startswith('```'):
                explanation_lines.append(line)
            elif capturing and not line:
                break
        
        explanation = ' '.join(explanation_lines)
        
        if explanation:
            return explanation
        
        # Fallback: usa as primeiras linhas n√£o-c√≥digo como explica√ß√£o
        non_code_lines = []
        for line in lines:
            line = line.strip()
            if line and not line.startswith('```') and not any(keyword in line for keyword in ['graph', 'sequenceDiagram']):
                non_code_lines.append(line)
                if len(non_code_lines) >= 3:
                    break
        
        return ' '.join(non_code_lines) if non_code_lines else "Diagrama gerado conforme solicitado."
    
    def _extract_suggestions(self, response: str) -> List[str]:
        """Extrai sugest√µes da resposta do LLM"""
        lines = response.split('\n')
        suggestions = []
        capturing = False
        
        for line in lines:
            line = line.strip()
            
            # Identifica se√ß√£o de sugest√µes
            if any(keyword in line.lower() for keyword in ['suggestions', 'sugest√µes', 'melhorias', 'improvements']):
                capturing = True
                continue
            
            # Captura sugest√µes (linhas com bullets ou n√∫meros)
            if capturing and line:
                if line.startswith(('-', '*', '‚Ä¢')) or line[0].isdigit():
                    # Remove bullets e n√∫meros
                    suggestion = line.lstrip('-*‚Ä¢0123456789. ').strip()
                    if suggestion:
                        suggestions.append(suggestion)
                elif not line:
                    break
        
        # Fallback: sugest√µes padr√£o
        if not suggestions:
            suggestions = [
                "Considere adicionar mais detalhes se necess√°rio",
                "Verifique se todos os elementos est√£o claramente rotulados",
                "Teste a renderiza√ß√£o do diagrama"
            ]
        
        return suggestions
    
    def _get_fallback_diagram(self) -> str:
        """Retorna diagrama de fallback em caso de erro"""
        return """graph TD
    A[In√≠cio] --> B[Processo]
    B --> C[Decis√£o]
    C -->|Sim| D[A√ß√£o 1]
    C -->|N√£o| E[A√ß√£o 2]
    D --> F[Fim]
    E --> F"""
    
    async def process_message(self, user_message: str, diagram_type: str = "sequence") -> str:
        """
        Processa mensagem do usu√°rio e gera diagrama
        
        Args:
            user_message: Descri√ß√£o do diagrama desejado
            diagram_type: Tipo de diagrama (sequence, flowchart, etc.)
            
        Returns:
            Resposta formatada com c√≥digo Mermaid e explica√ß√£o
        """
        try:
            # Cria requisi√ß√£o
            request = MermaidRequest(
                prompt=user_message,
                diagram_type=diagram_type
            )
            
            # Gera diagrama
            response = await self.generate_diagram(request)
            
            # Formata resposta para exibi√ß√£o
            formatted_response = self._format_response(response)
            
            return formatted_response
            
        except Exception as e:
            return f"‚ùå Erro ao processar solicita√ß√£o: {str(e)}"
    
    def _format_response(self, response: MermaidResponse) -> str:
        """Formata resposta para exibi√ß√£o no chat"""
        formatted = f"""üé® **Diagrama {response.diagram_type.title()} Gerado**

üìù **Explica√ß√£o:**
{response.explanation}

üìä **C√≥digo Mermaid:**
```mermaid
{response.mermaid_code}
```

üí° **Sugest√µes:**"""
        
        for i, suggestion in enumerate(response.suggestions, 1):
            formatted += f"\n{i}. {suggestion}"
        
        return formatted
    
    def get_supported_diagrams(self) -> List[Dict[str, str]]:
        """Retorna lista de tipos de diagrama suportados"""
        return [
            {"type": "sequence", "name": "Diagrama de Sequ√™ncia", "description": "Intera√ß√µes entre entidades ao longo do tempo"},
            {"type": "flowchart", "name": "Fluxograma", "description": "Fluxo de processos e decis√µes"},
            {"type": "classDiagram", "name": "Diagrama de Classes", "description": "Estruturas orientadas a objetos"},
            {"type": "stateDiagram", "name": "Diagrama de Estados", "description": "M√°quinas de estado e transi√ß√µes"},
            {"type": "gantt", "name": "Gr√°fico de Gantt", "description": "Cronogramas e planejamento"},
            {"type": "erDiagram", "name": "Diagrama ER", "description": "Modelos de dados e relacionamentos"},
            {"type": "journey", "name": "Jornada do Usu√°rio", "description": "Experi√™ncia do usu√°rio passo a passo"}
        ]
    
    def get_agent_info(self) -> Dict[str, Any]:
        """Retorna informa√ß√µes sobre o agente"""
        return {
            "name": "Tool Mermaid Agent",
            "version": "1.0.0",
            "type": "diagram_generation",
            "capabilities": [
                "Gera√ß√£o de diagramas Mermaid",
                "M√∫ltiplos tipos de diagrama",
                "Explica√ß√µes detalhadas",
                "Sugest√µes de melhorias",
                "Hist√≥rico de diagramas"
            ],
            "supported_diagrams": [d["type"] for d in self.get_supported_diagrams()],
            "mcp_integration": self.mcp_available,
            "diagrams_generated": len(self.diagram_history)
        }
    
    def get_diagram_history(self) -> List[Dict[str, Any]]:
        """Retorna hist√≥rico de diagramas gerados"""
        return self.diagram_history.copy()
    
    def reset_conversation(self):
        """Reseta hist√≥rico de conversa"""
        self.diagram_history = []
        print("üîÑ Hist√≥rico de diagramas resetado")